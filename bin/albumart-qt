#!/usr/bin/python
# -*- coding: iso-8859-1 -*-

"""
QT-frontend for the album image downloader.

Copyright (C) 2003, 2004 Sami Kyöstilä <skyostil@kempele.fi>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
at your option) any later version.
"""

import os
import sys
import traceback
import encodings
import imghdr
import StringIO

def getBaseDir():
        path = os.path.dirname(sys.argv[0])
        if os.path.split(path)[-1]=='bin':
                path=os.path.dirname(path)
        return path

def getLibDir():
        return os.path.join(getBaseDir(),"lib","albumart")

def getShareDir():
        return os.path.join(getBaseDir(),"share","albumart")

# first, find out where our program and data files are and set up sys.path accordingly.
sys.path = [getBaseDir(), getLibDir()] + sys.path

import albumart
import version
import config

import urllib
import tempfile
import Image
import ConfigParser
from qt import *

# see if we're using an old Qt version
if qVersion().split(".")[0]=="2":
        from albumartdialog_qt230 import AlbumArtDialog
else:
        # if the Qt version is older than 3.1, then use an alternate ui builder.
        try:
                if map(int, qVersion().split("."))[1]<1:
                        from albumartdialog_qt300 import AlbumArtDialog
                        sys.stderr.write("Warning: Your installed Qt version is too old (3.0.x). Please upgrade!\n")
                else:
                        raise 1
        except:
                from albumartdialog import AlbumArtDialog

class CoverDownloadedEvent(QCustomEvent):
        id = QEvent.User
        def __init__(self,thread,filename):
                QCustomEvent.__init__(self,self.id)
                self.filename = filename
                self.thread = thread

class TaskFinishedEvent(QCustomEvent):
        id = QEvent.User+1
        def __init__(self,thread,message = None):
                QCustomEvent.__init__(self,self.id)
                self.thread = thread
                self.message = message

class ExceptionEvent(QCustomEvent):
        id = QEvent.User+2
        def __init__(self,x):
                QCustomEvent.__init__(self,self.id)
                self.exception = x

class ProgressEvent(QCustomEvent):
        id = QEvent.User+3
        def __init__(self,thread,progress,total):
                QCustomEvent.__init__(self,self.id)
                self.thread = thread
                self.progress = progress
                self.total = total

class StatusEvent(QCustomEvent):
        id = QEvent.User+4
        def __init__(self,thread,text):
                QCustomEvent.__init__(self,self.id)
                self.thread = thread
                self.text = text

class ReloadEvent(QCustomEvent):
        id = QEvent.User+5
        def __init__(self,thread):
                QCustomEvent.__init__(self,self.id)
                self.thread = thread

class Process(QThread):
        def __init__(self,dialog):
                QThread.__init__(self)
                self.dialog = dialog
                self.canceled = 0

        def cancel(self):
                self.canceled = 1

        def isCanceled(self):
                return self.canceled

        def setProgress(self, progress, total):
                self.postEvent(self.dialog, ProgressEvent(self, progress, total))

        def setStatusText(self, text):
                self.postEvent(self.dialog, StatusEvent(self, text))
                
        def setComplete(self, message = None):
                self.postEvent(self.dialog, TaskFinishedEvent(self, message))

        def triggerReload(self):
                self.postEvent(self.dialog, ReloadEvent(self))

        def run(self):
                pass

class CoverDownloaderProcess(Process):
        "Cover Download"
        def __init__(self,dialog,artist,album):
                Process.__init__(self, dialog)
                self.dialog = dialog
                self.artist = artist
                self.album = album

        def run(self):
                coversFound = 0
		if self.album and self.artist and len(self.album) and len(self.artist):
	                self.setStatusText("Searching images for '%s' by %s..." % (self.album, self.artist))
		elif len(self.album):
	                self.setStatusText("Searching images for the album '%s'..." % (self.album))
		elif len(self.artist):
	                self.setStatusText("Searching images for the artist %s..." % (self.artist))
                        
                try:
                        for c in albumart.getAvailableCovers(self.artist, self.album):
                                coversFound += 1
                                if self.isCanceled():
                                        break
                                        
                                img = Image.open(c)
                                img.load()
                                
                                # convert to JPEG if needed
                                if img.format != "JPEG":
                                    img = img.convert("RGB")
                                    img.save(c)
                                        
                                self.postEvent(self.dialog, CoverDownloadedEvent(self,c))
                                # better fake progress than none at all :)
                                # we can't tell how many covers we've
                                # downloaded as they may have been blank or
                                # corrupt.
	                        self.setProgress(coversFound-1,coversFound)
                except Exception,x:
                        self.postEvent(self.dialog, ExceptionEvent(x))

                if coversFound > 0:
                        self.setComplete()
                else:
                        self.setComplete("Sorry, no cover images were found. Try simpler keywords.\nHowever, if you already have a cover image you'd like to use,\ngo ahead drop it on the cover image list.")

class AutoDownloadProcess(Process):
        "Automatic Cover Download"
        def __init__(self, dialog, dir, items):
                Process.__init__(self, dialog)
                self.items = items
                self.dir = dir

        def run(self):
                itemsProcessed = 0
                recognized = 0
                coversFound = 0
                coversInstalled = 0
                
                for path in self.items:
                        if self.isCanceled():
                                break

                        (artist,album)=albumart.guessArtistAndAlbum(path.replace(self.dir,""))

                        if artist and album:
                                recognized += 1
                                self.setStatusText('Searching cover for "%s" by %s...' % (album, artist))
                                for cover in albumart.getAvailableCovers(artist, album, requireExactMatch=1):
                                        try:
                                                img = Image.open(cover)
                                                img.load()
                                                coversFound += 1

                                                # convert to JPEG if needed
                                                if img.format != "JPEG":
                                                        img = img.convert("RGB")
                                                        img.save(cover)

                                                albumart.setCover(path,cover)
                                                coversInstalled += 1
                                        except Exception,x:
                                                print str(x)
                                        break
                                    
                        itemsProcessed += 1
                        self.setProgress(itemsProcessed, len(self.items))

                self.triggerReload()
                self.setComplete(
                        "Out of a total of %d folders, %d were recognized, %d matching covers were found and %d were installed." %
                        (len(self.items), recognized, coversFound, coversInstalled))

class SynchronizeProcess(Process):
        "Cover Image Synchronization"
        def __init__(self, dialog, dir, items):
                Process.__init__(self, dialog)
                self.items = items
                self.dir = dir

        def run(self):
                itemsProcessed = 0
                
                for path in self.items:
                        if self.isCanceled():
                                break

                        self.setStatusText('Synchronizing %s...' % (path.replace(self.dir,"")))
                        albumart.synchronizeCovers(path)
                                    
                        itemsProcessed += 1
                        self.setProgress(itemsProcessed, len(self.items))

                self.triggerReload()
                self.setComplete()

class AlbumArt(AlbumArtDialog):
        def __init__(self,parent = None,name = None,fl = 0):
                AlbumArtDialog.__init__(self,parent,name,fl)
                self.config = ConfigParser.ConfigParser()
                self.moduleAttributeMap = {}
                self.iconSize = 64
                self.dir = ""

                # load the configuration
                try:
                        fn = os.path.join(config.getConfigPath("albumart"), "config")
                        self.config.read(fn)

                        if not self.config.has_section("albumart"):
                                self.config.add_section("albumart")

                        self.config.set("albumart", "sources", "albumart_source_amazon.Amazon")
                        self.config.set("albumart", "targets", "albumart_target_freedesktop.Freedesktop:albumart_target_windows.Windows:albumart_target_id3v2.ID3v2")

                        self.settingsMenu = QPopupMenu()
                        self.connect(self.settingsMenu,SIGNAL("activated(int)"), self.settingsMenuActivated)
                        self.menubar.insertItem("&Settings", self.settingsMenu, -1, 3)

                        # global settings
                        try:
                                self.showCoversAction.setOn(self.config.getboolean("albumart", "showcovers"))
                        except Exception,x:
                                pass

                        try:
                                self.iconSize = self.config.getint("albumart", "iconsize")
                        except Exception,x:
                                pass

                        if self.iconSize == 16:
                                self.viewIcon_SizeSmallAction.setOn(1)
                        elif self.iconSize == 32:
                                self.viewIcon_SizeMediumAction.setOn(1);
                        elif self.iconSize == 64:
                                self.viewIcon_SizeLargeAction.setOn(1);

                        for s in self.config.get("albumart", "sources").split(":"):
                                mod = self.loadModule(s)
                                albumart.addSource(mod)

                        self.settingsMenu.insertSeparator()

                        for t in self.config.get("albumart", "targets").split(":"):
                                mod = self.loadModule(t)
                                albumart.addTarget(mod)
                except Exception,x:
                        sys.stderr.write("Unable to load configuration: %s\n" % str(x))
                        pass

                self.loadIcons()
                self.show()

                # restore the previous directory
                try:
                        if len(sys.argv)>1:
                                path = sys.argv[1]
                        else:
                                path = self.config.get("albumart", "lastDirectory")
                        self.walk(path)
                except Exception, x:
                        print x
                        pass

        def scaleIconPixmap(self, pixmap):
                if not pixmap.isNull() and pixmap.width()>0 and pixmap.height()>0:
                        try:
                                pixmap.convertFromImage(pixmap.convertToImage().scale(self.iconSize,self.iconSize))
                        except AttributeError:
                                # for older Qt 2.x
                                pixmap.convertFromImage(pixmap.convertToImage().smoothScale(self.iconSize,self.iconSize))
                return pixmap

        def loadIcons(self):
                self.coverPixmap = QPixmap(os.path.join(getShareDir(),"cover.png"))
                self.noCoverPixmap = QPixmap(os.path.join(getShareDir(),"nocover.png"))

                self.coverPixmap = self.scaleIconPixmap(self.coverPixmap)
                self.noCoverPixmap = self.scaleIconPixmap(self.noCoverPixmap)

                # replace ugly icons without alpha channel
                try:
                        self.fileOpenAction.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"fileopen.png"))))
                        self.fileExitAction.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"exit.png"))))
                        self.helpAboutAction.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"icon.png"))))
                        self.reloadAction.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"reload.png"))))
                        self.nextAction.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"1rightarrow.png"))))
                        self.previousAction.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"1leftarrow.png"))))
                        self.pushDownload.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"download.png"))))
                        self.pushSet.setIconSet(QIconSet(QPixmap(os.path.join(getShareDir(),"filesave.png"))))
                except:
                        # if that doesn't work, never mind
                        pass

        def loadModule(self,id):
                try:
                        (mod, cls) = id.split(".")
                        exec("import %s" % (mod))
                        exec("cfg = %s.defaultConfig.copy()" % (mod))
                        exec("cfgdesc = %s.configDesc" % (mod))
                        exec("c = %s.%s()" % (mod,cls))

                        # load configuration
                        try:
                                if sys.version_info[:2] == (2,2):
                                    for key in self.config.options(mod):
                                          cfg[key] = self.config.get(mod,key)
                                else:
                                    for (key,value) in self.config.items(mod):
                                          cfg[key] = value
                        except:
                                pass

                        c.__configuration__ = cfg

                        for (key,desc) in cfgdesc.items():
                                i = self.settingsMenu.insertItem(desc[1])
                                self.moduleAttributeMap[i] = (c,key,desc)

                                try:
                                        if desc[0]=="boolean":
                                                if cfg[key]==1 or self.config.getboolean(mod,key):
                                                        self.settingsMenu.setItemChecked(i, 1)
                                                        cfg[key] = 1
                                                else:
                                                        cfg[key] = 0
                                except:
                                        pass

                        c.configure(cfg)
                        return c
                except Exception,x:
                        print x
                        sys.stderr.write("Unable to load module '%s'.\n" % id)
                        raise

        def showCoversAction_toggled(self, enabled):
                self.config.set("albumart", "showcovers", enabled)
                self.reloadAction_activated()

        def iconSizeSmallAction_toggled(self, enabled):
                if enabled:
                        self.iconSize = 16
                        self.config.set("albumart", "iconsize", self.iconSize)
                        self.loadIcons()
                        self.reloadAction_activated()

        def iconSizeMediumAction_toggled(self, enabled):
                if enabled:
                        self.iconSize = 32
                        self.config.set("albumart", "iconsize", self.iconSize)
                        self.loadIcons()
                        self.reloadAction_activated()

        def iconSizeLargeAction_toggled(self, enabled):
                if enabled:
                        self.iconSize = 64
                        self.config.set("albumart", "iconsize", self.iconSize)
                        self.loadIcons()
                        self.reloadAction_activated()

        def settingsMenuActivated(self, id):
                enabled = not self.settingsMenu.isItemChecked(id)

                if self.moduleAttributeMap.has_key(id):
                        (mod,key,desc) = self.moduleAttributeMap[id]

                        if desc[0] == "boolean":
                                self.settingsMenu.setItemChecked(id, enabled)
                                mod.__configuration__[key] = enabled
                                mod.configure(mod.__configuration__)
                        elif desc[0] == "string":
                                (text,status) = QInputDialog.getText(desc[1], desc[2], QLineEdit.Normal, mod.__configuration__[key], self)
                                if status:
                                        mod.__configuration__[key] = unicode(text)
                                        mod.configure(mod.__configuration__)

        def fileExit(self):
                self.close()

        def closeEvent(self, ce):
                # delete the downloaded covers
                try:
                        for f in self.covers:
                                os.unlink(f)
                except:
                        pass

                # save the configuration
                try:
                        for mod in albumart.sources + albumart.targets:
                                for (key,value) in mod.__configuration__.items():
                                        if not self.config.has_section(mod.__module__):
                                                self.config.add_section(mod.__module__)
                                        self.config.set(mod.__module__, key, value)

                        fn = os.path.join(config.getConfigPath("albumart"), "config")
                        self.config.write(open(fn,"w"))
                except:
                        raise

                ce.accept()

        def getPixmapForPath(self, path):
                "Returns a QPixmap for the given path."
                if albumart.hasCover(path):
                        filename = albumart.getCover(path)

                        if filename:
                                # if we're running on Qt 2, convert the image to a png.
                                if qVersion().split(".")[0]=='2' and imghdr.what(filename) != "png":
                                        try:
                                            i = Image.open(filename)
                                            s = StringIO.StringIO()
                                            i.save(s, "PNG")
                                            pixmap = QPixmap()
                                            pixmap.loadFromData(s.getvalue())
                                        except IOError:
                                            return self.noCoverPixmap
                                else:
                                    pixmap = QPixmap(filename)
                                    
                                #pixmap = self.scaleIconPixmap(pixmap)
                                if pixmap.width()>0 and pixmap.height()>0:
                                        return pixmap
                                else:
                                        return self.noCoverPixmap
                        else:
                                return self.noCoverPixmap
                return self.noCoverPixmap

        def getIconForPath(self, path):
                "Returns a QPixmap that can be used as an icon for the given path."
                if self.showCoversAction and not self.showCoversAction.isOn():
                        if albumart.hasCover(path):
                                return self.scaleIconPixmap(self.coverPixmap)
                        return self.scaleIconPixmap(self.noCoverPixmap)
                return self.scaleIconPixmap(self.getPixmapForPath(path))

        def process(self, root, dirname, names):
                # repaint every 10 items.
                if self.dirlist.childCount()%10==0:
                        qApp.processEvents()

                path = dirname

                # filter out hidden directories
                for d in dirname.split(os.sep):
                        if len(d) and d[0]==".":
                                return

                # ugly portability hack
                if len(root):
                        if "\\" in root:
                                if not root[-1] == "\\" : root+="\\"
                        else:
                                if not root[-1] == "/": root+="/"

                dirname=dirname.replace(root,"")

                if not len(dirname):
                        dirname="."

                (artist,album)=albumart.guessArtistAndAlbum(dirname)

                item = QListViewItem(self.dirlist, dirname, artist, album)
                item.setPixmap(0, self.getIconForPath(path))

        def walk(self,path):
                self.dir = path

                self.pushSet.setEnabled(0)            
                self.fileOpenAction.setEnabled(0)
                self.pushDownload.setEnabled(0)
                self.artistEdit.setEnabled(0)
                self.albumEdit.setEnabled(0)
                self.artistEdit.clear()
                self.removeAction.setEnabled(0)
                self.albumEdit.clear()
                self.coverview.setEnabled(0)
                self.coverview.clear()
                self.albumIcon.setPixmap(QPixmap())
                self.albumIcon.setEnabled(0)
                self.autoDownloadAction.setEnabled(0)
                self.synchronizeAction.setEnabled(0)
                self.dirlist.setEnabled(1)
                self.dirlist.clear()

                self.statusBar().message("Reading directory...")
                self.setCursor(Qt.waitCursor)
                os.path.walk(path, self.process, path)
                self.statusBar().message("Ready",5000)
                self.setCursor(Qt.arrowCursor)

                self.pushDownload.setEnabled(0)

                try:
                        self.reloadAction.setEnabled(1)
                        self.nextAction.setEnabled(1)
                        self.previousAction.setEnabled(1)
                        self.autoDownloadAction.setEnabled(1)
                        self.synchronizeAction.setEnabled(1)
                        self.fileOpenAction.setEnabled(1)
                except:
                        pass

        def helpAbout(self):
                QMessageBox.information(self, version.__program__, """%s version %s by %s.
http://kempele.fi/~skyostil/projects/albumart

Amazon web api wrapper by Mark Pilgrim and Michael Josephson (http://www.josephson.org/projects/pyamazon/)
Icons by Everaldo Coelho (http://www.everaldo.com) et al.
PyID3 by Myers Carpenter (http://icepick.info/projects/pyid3/)
""" %
(version.__program__,version.__version__,version.__author__))

        def fileOpen(self):
                d=self.getQString(QFileDialog.getExistingDirectory(self.dir,self,"Choose a directory that contains one or more albums","Choose a directory", 1))
                if d and len(d):
                        self.config.set("albumart", "lastDirectory", d)
                        self.walk(d)

        def reloadAction_activated(self):
                if len(self.dir):
                        self.walk(self.dir)

        def removeAction_activated(self):
                if QMessageBox.information(self, "Confirm deletion", "Are you sure you want to delete the selected cover image?", QMessageBox.Yes, QMessageBox.No+QMessageBox.Default+QMessageBox.Escape) == QMessageBox.Yes:
                        path = os.path.join(self.dir,self.getQString(self.selectedAlbum.text(0)))


                        self.setCursor(Qt.waitCursor)
                        self.statusBar().message("Deleting selected cover image...")

                        try:
                                albumart.removeCover(path)
                                self.updateIcon()
                                self.selectedAlbum.setPixmap(0,self.getIconForPath(path))
                        except Exception,x:
                                traceback.print_exc(file=sys.stdout)
                                QMessageBox.critical(self, version.__program__,"The following error occured while removing the cover image:\n%s"%str(x))

                        self.setCursor(Qt.arrowCursor)
                        self.statusBar().message("Ready",5000)

        def nextAction_activated(self):
                item = self.dirlist.selectedItem()

                if not item:
                        item = self.dirlist.firstChild()

                while item:
                        item = item.itemBelow()
                        if not item: break
                        path = os.path.join(self.dir, self.getQString(item.text(0)))
                        if not albumart.hasCover(path):
                                self.dirlist.setSelected(item, 1)
                                self.dirlist.ensureItemVisible(item)
                                break

        def previousAction_activated(self):
                item = self.dirlist.selectedItem()

                if not item:
                        item = self.dirlist.lastChild()

                while item:
                        item = item.itemAbove()
                        if not item: break
                        path = os.path.join(self.dir, self.getQString(item.text(0)))
                        if not albumart.hasCover(path):
                                self.dirlist.setSelected(item, 1)
                                self.dirlist.ensureItemVisible(item)
                                break

        def startProcess(self, process):
                self.progressDialog = QProgressDialog(self, "progress", 1)
                self.progressDialog.setCaption(process.__doc__)
                self.thread = process

                # looks like trolltech fixed their spelling in Qt 3
                if qVersion().split(".")[0]=="2":
                        self.progressDialog.connect(self.progressDialog, SIGNAL("cancelled()"), self.processCanceled)
                else:
                        self.progressDialog.connect(self.progressDialog, SIGNAL("canceled()"), self.processCanceled)

                self.progressDialog.show()
                self.thread.start()

        def processCanceled(self):
                if self.thread:
                        self.thread.cancel()

        def autoDownloadAction_activated(self):
                item = self.dirlist.firstChild()
                items = []
                recognized = 0
                coversFound = 0
                coversInstalled = 0

                while item:
                        item = item.itemBelow()
                        if not item: break
                        path = os.path.join(self.dir, self.getQString(item.text(0)))
                        if not albumart.hasCover(path):
                                items.append(path)

                self.startProcess(AutoDownloadProcess(self, self.dir, items))

        def synchronizeAction_activated(self):
                item = self.dirlist.firstChild()
                items = []

                while item:
                        item = item.itemBelow()
                        if not item: break
                        path = os.path.join(self.dir, self.getQString(item.text(0)))
                        if albumart.hasCover(path):
                                items.append(path)

                self.startProcess(SynchronizeProcess(self, self.dir, items))

        def dirlist_selectionChanged(self,a0):
		# delete downloaded covers
                try:
                        for f in self.covers:
                                os.unlink(f)
                except:
                        pass
	
                self.selectedAlbum = a0
                self.coverview.clear()
                self.artistEdit.setText(a0.text(1))
                self.albumEdit.setText(a0.text(2))
                self.pushDownload.setEnabled(1)
                self.removeAction.setEnabled(1)
                self.pushSet.setEnabled(0)
                self.artistEdit.setEnabled(1)
                self.albumEdit.setEnabled(1)
                self.coverview.setEnabled(1)
                self.coverfiles = {}    # a map of listiview items to cover files
                self.covers = []        # a list of downloaded covers
                self.thread = None
                self.statusBar().message("")
                self.updateIcon()

        def getQString(self, qstring):
                return unicode(qstring).encode("latin-1", "replace")

        def updateIcon(self):
                # Try to load the current album cover image and display it as the folder icon.
                try:
                        self.albumIcon.setEnabled(0)
                        self.albumIcon.setPixmap(QPixmap())
                        path = os.path.join(self.dir,self.getQString(self.selectedAlbum.text(0)))

                        if albumart.hasCover(path):
                                pixmap = self.getPixmapForPath(path)
                                image = pixmap.convertToImage()

                                if not image.isNull() and image.width()>1 and image.height()>1:
                                        image = image.smoothScale(60,60)
                                        pixmap.convertFromImage(image)
                                        self.albumIcon.setPixmap(pixmap)
                                        self.albumIcon.setEnabled(1)
                except:
                        pass

        def albumIcon_clicked(self):
                # Try to load the current album cover image and display it in as new window
                try:
                        path = os.path.join(self.dir,self.getQString(self.selectedAlbum.text(0)))
                        pixmap = self.getPixmapForPath(path)
                        self.coverPreviewWindow = QLabel(None)
                        self.coverPreviewWindow.setPixmap(pixmap)
                        self.coverPreviewWindow.setFixedSize(pixmap.width(), pixmap.height())
                        self.coverPreviewWindow.setCaption("Cover image for " + self.getQString(self.selectedAlbum.text(0)))
                        self.coverPreviewWindow.show()
                except:
                        pass

        def addCoverToList(self,coverfile):
                # if we're running on Qt 2, convert the image to a png.
                try:
                        if qVersion().split(".")[0]=='2' and imghdr.what(coverfile) != "png":
                                i = Image.open(coverfile)
                                s = StringIO.StringIO()
                                i.save(s, "PNG")
                                pixmap = QPixmap()
                                pixmap.loadFromData(s.getvalue())
                                image = pixmap.convertToImage()
                        else:
                                image = QImage(coverfile)
                except IOError:
                        return 0

                if not image.isNull() and image.width()>1 and image.height()>1:
                        # if we're running on Qt 2, do the scaling a bit differently
                        if qVersion().split(".")[0]=='2':
                                image = image.smoothScale(256,256 * float(image.height())/float(image.width()))
                                pixmap = QPixmap()
                                pixmap.convertFromImage(image)
                                item = QIconViewItem(self.coverview, None, pixmap)
                        else:
                                image = image.smoothScale(256,256,QImage.ScaleMin)
                                item = QIconViewItem(self.coverview, None, QPixmap(image))

                        self.coverfiles[item] = coverfile
                        return 1
                return 0

        def customEvent(self,event):
                try:
                        # if the message was sent by an older thread, ignore it.
                        if self.thread != event.thread:
                                return
                except AttributeError:
                        pass
            
                if event.type()==CoverDownloadedEvent.id:
                        self.covers.append(event.filename)
                        self.addCoverToList(event.filename)
                elif event.type()==TaskFinishedEvent.id:
                        self.thread.wait()
                        self.thread = None

                        if self.progressDialog:
                                self.progressDialog.close()

                        if event.message:
                                QMessageBox.information(self, version.__program__,event.message)

                        self.pushDownload.setEnabled(1)
                elif event.type()==ExceptionEvent.id:
                        QMessageBox.critical(self, version.__program__,"The following error occured while downloading cover images:\n%s"%str(event.exception))
                elif event.type()==ProgressEvent.id:
                        if self.progressDialog:
                                self.progressDialog.setTotalSteps(event.total)
                                self.progressDialog.setProgress(event.progress)
                elif event.type()==StatusEvent.id:
                        if self.progressDialog:
                                self.progressDialog.setLabelText(event.text)
                elif event.type()==ReloadEvent.id:
                        self.reloadAction_activated()

                del event

        def pushDownload_clicked(self):
                # delete the previously downloaded covers
                try:
                        for f in self.covers:
                                os.unlink(f)
                except:
                        pass

                self.coverview.clear()
                self.pushSet.setEnabled(0)
                self.pushDownload.setEnabled(0)
                self.coverfiles = {}
                self.covers = []

                # start the downloader thread
                self.startProcess(CoverDownloaderProcess(self,self.getQString(self.artistEdit.text()), self.getQString(self.albumEdit.text())))

        def coverview_selectionChanged(self,a0):
                self.pushSet.setEnabled(1)
                self.selectedCover=a0

        def pushSet_clicked(self):
                self.setCursor(Qt.waitCursor)
                self.statusBar().message("Setting cover images...")

                path = os.path.join(self.dir,self.getQString(self.selectedAlbum.text(0)))
                cover = self.coverfiles[self.selectedCover]

                try:
                        albumart.setCover(path,cover)
                        self.pushSet.setEnabled(0)
                        self.selectedAlbum.setPixmap(0,self.getIconForPath(path))
                        self.updateIcon()
                except Exception,x:
                        traceback.print_exc(file=sys.stdout)
                        QMessageBox.critical(self, version.__program__,"The following error occured while setting the cover image:\n%s"%str(x))

                self.setCursor(Qt.arrowCursor)
                self.statusBar().message("Ready",5000)

        def coverview_dropped(self,a0,a1):
                if not self.selectedAlbum:
                        return

                text = QString()
                if QTextDrag.decode(a0, text):
                        try:
                                text=self.getQString(text)
                                text=urllib.unquote(text)

                                f=urllib.urlopen(text)
                                fn=tempfile.mktemp()

                                # write to a temporary file
                                o=open(fn,"wb")
                                o.write(f.read())
                                o.close()

                                # convert to JPEG
                                img = Image.open(fn)
                                img.load()
                                img = img.convert("RGB")
                                img.save(fn, "JPEG")
                                self.addCoverToList(fn)
                                self.covers.append(fn)
                        except Exception,x:
                                QMessageBox.critical(self, version.__program__,"The following error occured while adding the cover image:\n%s"%str(x))
                                raise

if __name__=="__main__":
        app = QApplication(sys.argv)
        mainwin = AlbumArt()
        app.setMainWidget(mainwin)

        if "--help" in sys.argv or "-h" in sys.argv:
                print """Assings cover images to directories holding albums.
Usage:
%s      [directory]""" % sys.argv[0]
                sys.exit(1)

        mainwin.show()

        try:
                app.exec_loop()
        except:
                pass

        sys.exit(0)
